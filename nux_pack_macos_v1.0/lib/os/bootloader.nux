# Nux Bootloader Library
# Boot process support

import "os.kernel";

# ============================================================
# MULTIBOOT HEADER
# ============================================================

var MULTIBOOT_MAGIC = 0x1BADB002;
var MULTIBOOT_ALIGN = 0x00000001;
var MULTIBOOT_MEMINFO = 0x00000002;
var MULTIBOOT_VIDEO = 0x00000004;

class MultibootInfo {
    var flags;
    var mem_lower;
    var mem_upper;
    var boot_device;
    var cmdline;
    var mods_count;
    var mods_addr;
    var mmap_length;
    var mmap_addr;
    var fb_addr;
    var fb_pitch;
    var fb_width;
    var fb_height;
    var fb_bpp;
    
    func init() {
        this.flags = 0;
    }
    
    func parse(addr) {
        this.flags = peek(addr);
        this.mem_lower = peek(addr + 4);
        this.mem_upper = peek(addr + 8);
        this.boot_device = peek(addr + 12);
        this.cmdline = peek(addr + 16);
        this.mods_count = peek(addr + 20);
        this.mods_addr = peek(addr + 24);
        this.mmap_length = peek(addr + 44);
        this.mmap_addr = peek(addr + 48);
        
        # Framebuffer info
        this.fb_addr = peek(addr + 88);
        this.fb_pitch = peek(addr + 92);
        this.fb_width = peek(addr + 96);
        this.fb_height = peek(addr + 100);
        this.fb_bpp = peek(addr + 104);
    }
    
    func get_memory_map() {
        var entries = new List();
        entries.init();
        
        var addr = this.mmap_addr;
        var end = addr + this.mmap_length;
        
        while (addr < end) {
            var entry = new MemoryMapEntry();
            entry.init();
            entry.size = peek(addr);
            entry.base_low = peek(addr + 4);
            entry.base_high = peek(addr + 8);
            entry.length_low = peek(addr + 12);
            entry.length_high = peek(addr + 16);
            entry.type = peek(addr + 20);
            entries.append(entry);
            
            addr = addr + entry.size + 4;
        }
        
        return entries;
    }
}

class MemoryMapEntry {
    var size;
    var base_low;
    var base_high;
    var length_low;
    var length_high;
    var type;
    
    func init() {}
    
    func base() {
        return this.base_low;
    }
    
    func length() {
        return this.length_low;
    }
    
    func is_available() {
        return this.type == 1;
    }
}

# ============================================================
# GDT SETUP
# ============================================================

class GDTEntry {
    var limit_low;
    var base_low;
    var base_middle;
    var access;
    var granularity;
    var base_high;
    
    func init() {}
    
    func set(base, limit, access_byte, gran) {
        this.base_low = base & 0xFFFF;
        this.base_middle = (base >> 16) & 0xFF;
        this.base_high = (base >> 24) & 0xFF;
        this.limit_low = limit & 0xFFFF;
        this.granularity = ((limit >> 16) & 0x0F) | (gran & 0xF0);
        this.access = access_byte;
    }
}

class GDT {
    var entries;
    var limit;
    var base;
    
    func init() {
        this.entries = new List();
        this.entries.init();
    }
    
    func add_entry(base, limit, access, gran) {
        var entry = new GDTEntry();
        entry.init();
        entry.set(base, limit, access, gran);
        this.entries.append(entry);
    }
    
    func setup_flat() {
        # Null descriptor
        this.add_entry(0, 0, 0, 0);
        
        # Kernel code segment
        this.add_entry(0, 0xFFFFFFFF, 0x9A, 0xCF);
        
        # Kernel data segment
        this.add_entry(0, 0xFFFFFFFF, 0x92, 0xCF);
        
        # User code segment
        this.add_entry(0, 0xFFFFFFFF, 0xFA, 0xCF);
        
        # User data segment
        this.add_entry(0, 0xFFFFFFFF, 0xF2, 0xCF);
        
        # TSS (added later)
    }
    
    func load() {
        this.limit = this.entries.length() * 8 - 1;
        # lgdt instruction
        asm("lgdt [gdt_ptr]");
    }
}

# ============================================================
# A20 LINE
# ============================================================

func enable_a20() {
    # Try BIOS method
    # asm("mov ax, 0x2401");
    # asm("int 0x15");
    
    # Try keyboard controller method
    a20_wait_input();
    # outb(0x64, 0xD1)
    a20_wait_input();
    # outb(0x60, 0xDF)
    a20_wait_input();
    
    # Try Fast A20
    # var a = inb(0x92)
    # outb(0x92, a | 2)
}

func a20_wait_input() {
    # while ((inb(0x64) & 2) != 0) {}
}

# ============================================================
# PROTECTED MODE SWITCH
# ============================================================

func enter_protected_mode() {
    asm("cli");
    
    enable_a20();
    
    # Load GDT
    var gdt = new GDT();
    gdt.init();
    gdt.setup_flat();
    gdt.load();
    
    # Set PE bit in CR0
    asm("mov eax, cr0");
    asm("or eax, 1");
    asm("mov cr0, eax");
    
    # Far jump to flush pipeline
    asm("jmp 0x08:protected_entry");
}

# ============================================================
# LONG MODE SWITCH (64-bit)
# ============================================================

func enter_long_mode(pml4_addr) {
    asm("cli");
    
    # Disable paging
    asm("mov eax, cr0");
    asm("and eax, ~(1 << 31)");
    asm("mov cr0, eax");
    
    # Set PAE
    asm("mov eax, cr4");
    asm("or eax, (1 << 5)");
    asm("mov cr4, eax");
    
    # Load PML4
    # asm("mov eax, pml4_addr");
    asm("mov cr3, eax");
    
    # Enable long mode in EFER
    asm("mov ecx, 0xC0000080");
    asm("rdmsr");
    asm("or eax, (1 << 8)");
    asm("wrmsr");
    
    # Enable paging
    asm("mov eax, cr0");
    asm("or eax, (1 << 31)");
    asm("mov cr0, eax");
    
    # Far jump to 64-bit code
    asm("jmp 0x08:long_mode_entry");
}

# ============================================================
# VGA TEXT MODE
# ============================================================

var VGA_BUFFER = 0xB8000;
var VGA_WIDTH = 80;
var VGA_HEIGHT = 25;

class VGAConsole {
    var cursor_x;
    var cursor_y;
    var color;
    
    func init() {
        this.cursor_x = 0;
        this.cursor_y = 0;
        this.color = 0x0F;  # White on black
    }
    
    func clear() {
        var i = 0;
        for (i = 0; i < VGA_WIDTH * VGA_HEIGHT; i = i + 1) {
            poke16(VGA_BUFFER + i * 2, 0x0F20);  # Space with color
        }
        this.cursor_x = 0;
        this.cursor_y = 0;
    }
    
    func putchar(c) {
        if (c == 10) {  # Newline
            this.cursor_x = 0;
            this.cursor_y = this.cursor_y + 1;
        } else if (c == 13) {  # Carriage return
            this.cursor_x = 0;
        } else {
            var offset = (this.cursor_y * VGA_WIDTH + this.cursor_x) * 2;
            poke8(VGA_BUFFER + offset, c);
            poke8(VGA_BUFFER + offset + 1, this.color);
            this.cursor_x = this.cursor_x + 1;
        }
        
        if (this.cursor_x >= VGA_WIDTH) {
            this.cursor_x = 0;
            this.cursor_y = this.cursor_y + 1;
        }
        
        if (this.cursor_y >= VGA_HEIGHT) {
            this.scroll();
            this.cursor_y = VGA_HEIGHT - 1;
        }
        
        this.update_cursor();
    }
    
    func print(str) {
        var i = 0;
        # for each char in str: putchar(c)
    }
    
    func scroll() {
        var i = 0;
        for (i = 0; i < VGA_WIDTH * (VGA_HEIGHT - 1); i = i + 1) {
            poke16(VGA_BUFFER + i * 2, peek16(VGA_BUFFER + (i + VGA_WIDTH) * 2));
        }
        for (i = VGA_WIDTH * (VGA_HEIGHT - 1); i < VGA_WIDTH * VGA_HEIGHT; i = i + 1) {
            poke16(VGA_BUFFER + i * 2, 0x0F20);
        }
    }
    
    func update_cursor() {
        var pos = this.cursor_y * VGA_WIDTH + this.cursor_x;
        # outb(0x3D4, 0x0F)
        # outb(0x3D5, pos & 0xFF)
        # outb(0x3D4, 0x0E)
        # outb(0x3D5, (pos >> 8) & 0xFF)
    }
    
    func set_color(fg, bg) {
        this.color = (bg << 4) | fg;
    }
}

# ============================================================
# EARLY BOOT HELPERS
# ============================================================

func detect_cpuid() {
    # Check if CPUID is available
    # Toggle ID bit in EFLAGS
    return 1;
}

func get_cpu_features() {
    var features = new Map();
    features.init();
    
    # cpuid(1)
    # Parse EAX, EBX, ECX, EDX
    
    return features;
}

func early_print(msg) {
    var console = new VGAConsole();
    console.init();
    console.print(msg);
}

func halt() {
    asm("cli");
    asm("hlt");
}

func poke8(addr, val) {
    poke(addr, val);
}

func poke16(addr, val) {
    poke(addr, val);
}

func peek16(addr) {
    return peek(addr);
}
