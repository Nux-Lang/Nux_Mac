# Nux Compression Library
# Data compression algorithms

class HuffmanNode {
    var frequency;
    var character;
    var left;
    var right;
    
    func init(freq, ch) {
        this.frequency = freq;
        this.character = ch;
        this.left = 0;
        this.right = 0;
    }
}

class HuffmanEncoder {
    var root;
    var codes;
    
    func init() {
        this.codes = new Map();
        this.codes.init();
    }
    
    func build_tree(data, length) {
        var frequencies = new Map();
        frequencies.init();
        
        var i = 0;
        for (i = 0; i < length; i = i + 1) {
            var ch = mem_read8(data + i);
            var freq = frequencies.get(ch);
            if (freq == 0) {
                freq = 0;
            }
            frequencies.put(ch, freq + 1);
        }
        
        # Build Huffman tree
        # ... (priority queue implementation)
    }
    
    func encode(data, length) {
        this.build_tree(data, length);
        
        var output = mem_alloc_aligned(length * 2, 8);
        var bit_pos = 0;
        
        var i = 0;
        for (i = 0; i < length; i = i + 1) {
            var ch = mem_read8(data + i);
            var code = this.codes.get(ch);
            
            # Write code bits to output
            # ... (implementation)
        }
        
        return output;
    }
}

func lz77_compress(data, length) {
    var window_size = 4096;
    var lookahead_size = 18;
    
    var output = mem_alloc_aligned(length * 2, 8);
    var out_pos = 0;
    var in_pos = 0;
    
    for (;;) {
        if (in_pos >= length) {
            break;
        }
        
        var best_match_dist = 0;
        var best_match_len = 0;
        
        var search_start = in_pos - window_size;
        if (search_start < 0) {
            search_start = 0;
        }
        
        var i = search_start;
        for (i = search_start; i < in_pos; i = i + 1) {
            var match_len = 0;
            
            for (;;) {
                if (match_len >= lookahead_size) {
                    break;
                }
                if (in_pos + match_len >= length) {
                    break;
                }
                
                if (mem_read8(data + i + match_len) == mem_read8(data + in_pos + match_len)) {
                    match_len = match_len + 1;
                }
                if (mem_read8(data + i + match_len) != mem_read8(data + in_pos + match_len)) {
                    break;
                }
            }
            
            if (match_len > best_match_len) {
                best_match_len = match_len;
                best_match_dist = in_pos - i;
            }
        }
        
        if (best_match_len >= 3) {
            mem_write16(output + out_pos, best_match_dist);
            mem_write8(output + out_pos + 2, best_match_len);
            out_pos = out_pos + 3;
            in_pos = in_pos + best_match_len;
        }
        if (best_match_len < 3) {
            mem_write8(output + out_pos, mem_read8(data + in_pos));
            out_pos = out_pos + 1;
            in_pos = in_pos + 1;
        }
    }
    
    return output;
}

func run_length_encode(data, length) {
    var output = mem_alloc_aligned(length * 2, 8);
    var out_pos = 0;
    var i = 0;
    
    for (;;) {
        if (i >= length) {
            break;
        }
        
        var current = mem_read8(data + i);
        var count = 1;
        
        for (;;) {
            if (i + count >= length) {
                break;
            }
            if (mem_read8(data + i + count) != current) {
                break;
            }
            if (count >= 255) {
                break;
            }
            count = count + 1;
        }
        
        mem_write8(output + out_pos, count);
        mem_write8(output + out_pos + 1, current);
        out_pos = out_pos + 2;
        i = i + count;
    }
    
    return output;
}

func crc32(data, length) {
    var crc = 0xFFFFFFFF;
    
    var i = 0;
    for (i = 0; i < length; i = i + 1) {
        var byte = mem_read8(data + i);
        crc = crc ^ byte;
        
        var j = 0;
        for (j = 0; j < 8; j = j + 1) {
            if ((crc & 1) != 0) {
                crc = (crc >> 1) ^ 0xEDB88320;
            }
            if ((crc & 1) == 0) {
                crc = crc >> 1;
            }
        }
    }
    
    return crc ^ 0xFFFFFFFF;
}
