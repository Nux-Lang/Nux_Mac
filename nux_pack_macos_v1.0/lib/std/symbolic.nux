// Nux Standard Library - Symbolic Computation
// Computer algebra, symbolic differentiation, and symbolic integration

// ===== SYMBOLIC EXPRESSION =====

fn sym_var(name) {
    // Symbolic variable
    return {type: "var", name: name};
}

fn sym_const(value) {
    // Symbolic constant
    return {type: "const", value: value};
}

fn sym_add(left, right) {
    // Symbolic addition
    return {type: "add", left: left, right: right};
}

fn sym_mul(left, right) {
    // Symbolic multiplication
    return {type: "mul", left: left, right: right};
}

fn sym_pow(base, exponent) {
    // Symbolic power
    return {type: "pow", base: base, exponent: exponent};
}

fn sym_sin(expr) {
    // Symbolic sine
    return {type: "sin", expr: expr};
}

fn sym_cos(expr) {
    // Symbolic cosine
    return {type: "cos", expr: expr};
}

fn sym_exp(expr) {
    // Symbolic exponential
    return {type: "exp", expr: expr};
}

fn sym_log(expr) {
    // Symbolic logarithm
    return {type: "log", expr: expr};
}

// ===== SYMBOLIC SIMPLIFICATION =====

fn sym_simplify(expr) {
    // Simplify symbolic expression
    if (expr.type == "const") {
        return expr;
    }
    
    if (expr.type == "var") {
        return expr;
    }
    
    if (expr.type == "add") {
        let left = sym_simplify(expr.left);
        let right = sym_simplify(expr.right);
        
        // 0 + x = x
        if (left.type == "const" && left.value == 0) {
            return right;
        }
        
        // x + 0 = x
        if (right.type == "const" && right.value == 0) {
            return left;
        }
        
        // c1 + c2 = c3
        if (left.type == "const" && right.type == "const") {
            return sym_const(left.value + right.value);
        }
        
        return sym_add(left, right);
    }
    
    if (expr.type == "mul") {
        let left = sym_simplify(expr.left);
        let right = sym_simplify(expr.right);
        
        // 0 * x = 0
        if ((left.type == "const" && left.value == 0) ||
            (right.type == "const" && right.value == 0)) {
            return sym_const(0);
        }
        
        // 1 * x = x
        if (left.type == "const" && left.value == 1) {
            return right;
        }
        
        // x * 1 = x
        if (right.type == "const" && right.value == 1) {
            return left;
        }
        
        // c1 * c2 = c3
        if (left.type == "const" && right.type == "const") {
            return sym_const(left.value * right.value);
        }
        
        return sym_mul(left, right);
    }
    
    if (expr.type == "pow") {
        let base = sym_simplify(expr.base);
        let exp = sym_simplify(expr.exponent);
        
        // x^0 = 1
        if (exp.type == "const" && exp.value == 0) {
            return sym_const(1);
        }
        
        // x^1 = x
        if (exp.type == "const" && exp.value == 1) {
            return base;
        }
        
        // c1^c2 = c3
        if (base.type == "const" && exp.type == "const") {
            return sym_const(pow(base.value, exp.value));
        }
        
        return sym_pow(base, exp);
    }
    
    return expr;
}

// ===== SYMBOLIC DIFFERENTIATION =====

fn sym_diff(expr, variable) {
    // Symbolic differentiation
    if (expr.type == "const") {
        return sym_const(0);
    }
    
    if (expr.type == "var") {
        if (expr.name == variable) {
            return sym_const(1);
        }
        return sym_const(0);
    }
    
    if (expr.type == "add") {
        // d/dx(f + g) = df/dx + dg/dx
        return sym_add(
            sym_diff(expr.left, variable),
            sym_diff(expr.right, variable)
        );
    }
    
    if (expr.type == "mul") {
        // d/dx(f * g) = f * dg/dx + g * df/dx
        return sym_add(
            sym_mul(expr.left, sym_diff(expr.right, variable)),
            sym_mul(expr.right, sym_diff(expr.left, variable))
        );
    }
    
    if (expr.type == "pow") {
        // d/dx(f^n) = n * f^(n-1) * df/dx
        return sym_mul(
            sym_mul(
                expr.exponent,
                sym_pow(expr.base, sym_add(expr.exponent, sym_const(-1)))
            ),
            sym_diff(expr.base, variable)
        );
    }
    
    if (expr.type == "sin") {
        // d/dx(sin(f)) = cos(f) * df/dx
        return sym_mul(
            sym_cos(expr.expr),
            sym_diff(expr.expr, variable)
        );
    }
    
    if (expr.type == "cos") {
        // d/dx(cos(f)) = -sin(f) * df/dx
        return sym_mul(
            sym_mul(sym_const(-1), sym_sin(expr.expr)),
            sym_diff(expr.expr, variable)
        );
    }
    
    if (expr.type == "exp") {
        // d/dx(exp(f)) = exp(f) * df/dx
        return sym_mul(
            sym_exp(expr.expr),
            sym_diff(expr.expr, variable)
        );
    }
    
    if (expr.type == "log") {
        // d/dx(log(f)) = (1/f) * df/dx
        return sym_mul(
            sym_pow(expr.expr, sym_const(-1)),
            sym_diff(expr.expr, variable)
        );
    }
    
    return expr;
}

// ===== SYMBOLIC INTEGRATION =====

fn sym_integrate(expr, variable) {
    // Symbolic integration (basic cases)
    if (expr.type == "const") {
        // ∫c dx = c*x
        return sym_mul(expr, sym_var(variable));
    }
    
    if (expr.type == "var" && expr.name == variable) {
        // ∫x dx = x^2/2
        return sym_mul(
            sym_const(0.5),
            sym_pow(sym_var(variable), sym_const(2))
        );
    }
    
    if (expr.type == "pow" && expr.base.type == "var" && 
        expr.base.name == variable && expr.exponent.type == "const") {
        // ∫x^n dx = x^(n+1)/(n+1)
        let n = expr.exponent.value;
        
        if (n != -1) {
            return sym_mul(
                sym_const(1.0 / (n + 1)),
                sym_pow(sym_var(variable), sym_const(n + 1))
            );
        } else {
            // ∫x^(-1) dx = log(x)
            return sym_log(sym_var(variable));
        }
    }
    
    if (expr.type == "sin") {
        // ∫sin(x) dx = -cos(x)
        return sym_mul(sym_const(-1), sym_cos(expr.expr));
    }
    
    if (expr.type == "cos") {
        // ∫cos(x) dx = sin(x)
        return sym_sin(expr.expr);
    }
    
    if (expr.type == "exp") {
        // ∫exp(x) dx = exp(x)
        return sym_exp(expr.expr);
    }
    
    // TODO: Implement more integration rules
    
    return {type: "integral", expr: expr, variable: variable};
}

// ===== SYMBOLIC EVALUATION =====

fn sym_eval(expr, bindings) {
    // Evaluate symbolic expression
    if (expr.type == "const") {
        return expr.value;
    }
    
    if (expr.type == "var") {
        return bindings[expr.name] || 0;
    }
    
    if (expr.type == "add") {
        return sym_eval(expr.left, bindings) + sym_eval(expr.right, bindings);
    }
    
    if (expr.type == "mul") {
        return sym_eval(expr.left, bindings) * sym_eval(expr.right, bindings);
    }
    
    if (expr.type == "pow") {
        return pow(sym_eval(expr.base, bindings), sym_eval(expr.exponent, bindings));
    }
    
    if (expr.type == "sin") {
        return sin(sym_eval(expr.expr, bindings));
    }
    
    if (expr.type == "cos") {
        return cos(sym_eval(expr.expr, bindings));
    }
    
    if (expr.type == "exp") {
        return exp(sym_eval(expr.expr, bindings));
    }
    
    if (expr.type == "log") {
        return log(sym_eval(expr.expr, bindings));
    }
    
    return 0;
}

// ===== SYMBOLIC TO STRING =====

fn sym_toString(expr) {
    // Convert symbolic expression to string
    if (expr.type == "const") {
        return "" + expr.value;
    }
    
    if (expr.type == "var") {
        return expr.name;
    }
    
    if (expr.type == "add") {
        return "(" + sym_toString(expr.left) + " + " + sym_toString(expr.right) + ")";
    }
    
    if (expr.type == "mul") {
        return "(" + sym_toString(expr.left) + " * " + sym_toString(expr.right) + ")";
    }
    
    if (expr.type == "pow") {
        return "(" + sym_toString(expr.base) + "^" + sym_toString(expr.exponent) + ")";
    }
    
    if (expr.type == "sin") {
        return "sin(" + sym_toString(expr.expr) + ")";
    }
    
    if (expr.type == "cos") {
        return "cos(" + sym_toString(expr.expr) + ")";
    }
    
    if (expr.type == "exp") {
        return "exp(" + sym_toString(expr.expr) + ")";
    }
    
    if (expr.type == "log") {
        return "log(" + sym_toString(expr.expr) + ")";
    }
    
    return "?";
}

// ===== POLYNOMIAL OPERATIONS =====

fn poly_create(coefficients) {
    // Create polynomial
    return {
        type: "polynomial",
        coefficients: coefficients
    };
}

fn poly_add(p1, p2) {
    // Add polynomials
    let maxLen = max(arr_length(p1.coefficients), arr_length(p2.coefficients));
    let result = [];
    
    let i = 0;
    while (i < maxLen) {
        let c1 = i < arr_length(p1.coefficients) ? p1.coefficients[i] : 0;
        let c2 = i < arr_length(p2.coefficients) ? p2.coefficients[i] : 0;
        arr_push(result, c1 + c2);
        i = i + 1;
    }
    
    return poly_create(result);
}

fn poly_mul(p1, p2) {
    // Multiply polynomials
    let len = arr_length(p1.coefficients) + arr_length(p2.coefficients) - 1;
    let result = arr_fill(len, 0);
    
    let i = 0;
    while (i < arr_length(p1.coefficients)) {
        let j = 0;
        while (j < arr_length(p2.coefficients)) {
            result[i + j] = result[i + j] + p1.coefficients[i] * p2.coefficients[j];
            j = j + 1;
        }
        i = i + 1;
    }
    
    return poly_create(result);
}

fn poly_eval(poly, x) {
    // Evaluate polynomial at x
    let result = 0;
    let power = 1;
    
    arr_forEach(poly.coefficients, fn(coeff) {
        result = result + coeff * power;
        power = power * x;
    });
    
    return result;
}
