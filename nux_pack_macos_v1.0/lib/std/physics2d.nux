# Nux 2D Physics Library
# Box2D-style physics engine

import "std.math";

# ============================================================
# VECTOR MATH
# ============================================================

class Vec2 {
    var x;
    var y;
    
    func init(vx, vy) {
        this.x = vx;
        this.y = vy;
    }
    
    func add(other) {
        var r = new Vec2();
        r.init(this.x + other.x, this.y + other.y);
        return r;
    }
    
    func sub(other) {
        var r = new Vec2();
        r.init(this.x - other.x, this.y - other.y);
        return r;
    }
    
    func scale(s) {
        var r = new Vec2();
        r.init(this.x * s, this.y * s);
        return r;
    }
    
    func dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    
    func cross(other) {
        return this.x * other.y - this.y * other.x;
    }
    
    func length() {
        return sqrt(this.x * this.x + this.y * this.y);
    }
    
    func normalize() {
        var len = this.length();
        if (len > 0) {
            var r = new Vec2();
            r.init(this.x / len, this.y / len);
            return r;
        }
        var z = new Vec2();
        z.init(0, 0);
        return z;
    }
    
    func perpendicular() {
        var r = new Vec2();
        r.init(-this.y, this.x);
        return r;
    }
    
    func rotate(angle) {
        var c = cos(angle);
        var s = sin(angle);
        var r = new Vec2();
        r.init(this.x * c - this.y * s, this.x * s + this.y * c);
        return r;
    }
}

func vec2(x, y) {
    var v = new Vec2();
    v.init(x, y);
    return v;
}

# ============================================================
# SHAPES
# ============================================================

class CircleShape {
    var type;
    var radius;
    
    func init(r) {
        this.type = "circle";
        this.radius = r;
    }
    
    func compute_mass(density) {
        return 3.14159 * this.radius * this.radius * density;
    }
    
    func compute_inertia(mass) {
        return 0.5 * mass * this.radius * this.radius;
    }
}

class PolygonShape {
    var type;
    var vertices;
    var normals;
    
    func init() {
        this.type = "polygon";
        this.vertices = new List();
        this.vertices.init();
        this.normals = new List();
        this.normals.init();
    }
    
    func set_as_box(half_w, half_h) {
        this.vertices.clear();
        this.vertices.append(vec2(-half_w, -half_h));
        this.vertices.append(vec2(half_w, -half_h));
        this.vertices.append(vec2(half_w, half_h));
        this.vertices.append(vec2(-half_w, half_h));
        this.compute_normals();
    }
    
    func compute_normals() {
        this.normals.clear();
        var count = this.vertices.length();
        var i = 0;
        for (i = 0; i < count; i = i + 1) {
            var v1 = this.vertices.get(i);
            var v2 = this.vertices.get((i + 1) % count);
            var edge = v2.sub(v1);
            var normal = edge.perpendicular().normalize();
            this.normals.append(normal);
        }
    }
    
    func compute_mass(density) {
        var area = 0;
        var count = this.vertices.length();
        var i = 0;
        for (i = 0; i < count; i = i + 1) {
            var v1 = this.vertices.get(i);
            var v2 = this.vertices.get((i + 1) % count);
            area = area + v1.cross(v2);
        }
        return abs(area) / 2 * density;
    }
}

class AABB {
    var min_x;
    var min_y;
    var max_x;
    var max_y;
    
    func init(minx, miny, maxx, maxy) {
        this.min_x = minx;
        this.min_y = miny;
        this.max_x = maxx;
        this.max_y = maxy;
    }
    
    func overlaps(other) {
        if (this.max_x < other.min_x) { return 0; }
        if (this.min_x > other.max_x) { return 0; }
        if (this.max_y < other.min_y) { return 0; }
        if (this.min_y > other.max_y) { return 0; }
        return 1;
    }
}

# ============================================================
# RIGID BODY
# ============================================================

var BODY_STATIC = 0;
var BODY_DYNAMIC = 1;
var BODY_KINEMATIC = 2;

class RigidBody {
    var position;
    var velocity;
    var angle;
    var angular_velocity;
    var force;
    var torque;
    var mass;
    var inv_mass;
    var inertia;
    var inv_inertia;
    var shape;
    var body_type;
    var friction;
    var restitution;
    
    func init(x, y, btype) {
        this.position = vec2(x, y);
        this.velocity = vec2(0, 0);
        this.angle = 0;
        this.angular_velocity = 0;
        this.force = vec2(0, 0);
        this.torque = 0;
        this.body_type = btype;
        this.friction = 0.3;
        this.restitution = 0.2;
        
        if (btype == BODY_STATIC) {
            this.mass = 0;
            this.inv_mass = 0;
            this.inertia = 0;
            this.inv_inertia = 0;
        }
    }
    
    func set_shape(s, density) {
        this.shape = s;
        if (this.body_type == BODY_DYNAMIC) {
            this.mass = s.compute_mass(density);
            this.inv_mass = 1 / this.mass;
            this.inertia = s.compute_inertia(this.mass);
            this.inv_inertia = 1 / this.inertia;
        }
    }
    
    func apply_force(f) {
        this.force = this.force.add(f);
    }
    
    func apply_impulse(impulse) {
        this.velocity = this.velocity.add(impulse.scale(this.inv_mass));
    }
    
    func integrate_forces(dt, gravity) {
        if (this.body_type != BODY_DYNAMIC) { return; }
        this.velocity = this.velocity.add(gravity.scale(dt));
        this.velocity = this.velocity.add(this.force.scale(this.inv_mass * dt));
        this.angular_velocity = this.angular_velocity + this.torque * this.inv_inertia * dt;
    }
    
    func integrate_velocity(dt) {
        if (this.body_type == BODY_STATIC) { return; }
        this.position = this.position.add(this.velocity.scale(dt));
        this.angle = this.angle + this.angular_velocity * dt;
        this.force = vec2(0, 0);
        this.torque = 0;
    }
}

# ============================================================
# COLLISION
# ============================================================

class Manifold {
    var body_a;
    var body_b;
    var penetration;
    var normal;
    
    func init(a, b) {
        this.body_a = a;
        this.body_b = b;
        this.penetration = 0;
        this.normal = vec2(0, 0);
    }
}

func circle_vs_circle(a, b, m) {
    var n = b.position.sub(a.position);
    var r = a.shape.radius + b.shape.radius;
    var d_sq = n.dot(n);
    if (d_sq > r * r) { return 0; }
    var d = sqrt(d_sq);
    if (d != 0) {
        m.penetration = r - d;
        m.normal = n.scale(1 / d);
    } else {
        m.penetration = a.shape.radius;
        m.normal = vec2(1, 0);
    }
    return 1;
}

func resolve_collision(m) {
    var a = m.body_a;
    var b = m.body_b;
    var rv = b.velocity.sub(a.velocity);
    var vel_along_normal = rv.dot(m.normal);
    if (vel_along_normal > 0) { return; }
    var e = min(a.restitution, b.restitution);
    var j = -(1 + e) * vel_along_normal / (a.inv_mass + b.inv_mass);
    var impulse = m.normal.scale(j);
    a.velocity = a.velocity.sub(impulse.scale(a.inv_mass));
    b.velocity = b.velocity.add(impulse.scale(b.inv_mass));
}

# ============================================================
# JOINTS
# ============================================================

class DistanceJoint {
    var body_a;
    var body_b;
    var length;
    var stiffness;
    
    func init(a, b, len) {
        this.body_a = a;
        this.body_b = b;
        this.length = len;
        this.stiffness = 1;
    }
    
    func solve(dt) {
        var delta = this.body_b.position.sub(this.body_a.position);
        var current_len = delta.length();
        if (current_len == 0) { return; }
        var dir = delta.scale(1 / current_len);
        var diff = current_len - this.length;
        var force = dir.scale(diff * this.stiffness);
        this.body_a.apply_force(force);
        this.body_b.apply_force(force.scale(-1));
    }
}

class RevoluteJoint {
    var body_a;
    var body_b;
    var anchor;
    
    func init(a, b, anc) {
        this.body_a = a;
        this.body_b = b;
        this.anchor = anc;
    }
    
    func solve(dt) {
        var world_a = this.body_a.position.add(this.anchor);
        var world_b = this.body_b.position.add(this.anchor);
        var delta = world_b.sub(world_a);
        var correction = delta.scale(0.5);
        this.body_a.position = this.body_a.position.add(correction.scale(this.body_a.inv_mass));
        this.body_b.position = this.body_b.position.sub(correction.scale(this.body_b.inv_mass));
    }
}

# ============================================================
# PHYSICS WORLD
# ============================================================

class PhysicsWorld {
    var bodies;
    var joints;
    var gravity;
    var iterations;
    
    func init() {
        this.bodies = new List();
        this.bodies.init();
        this.joints = new List();
        this.joints.init();
        this.gravity = vec2(0, 9.81);
        this.iterations = 10;
    }
    
    func add_body(body) {
        this.bodies.append(body);
        return body;
    }
    
    func add_joint(joint) {
        this.joints.append(joint);
        return joint;
    }
    
    func step(dt) {
        var i = 0;
        for (i = 0; i < this.bodies.length(); i = i + 1) {
            this.bodies.get(i).integrate_forces(dt, this.gravity);
        }
        
        var manifolds = this.find_collisions();
        
        var iter = 0;
        for (iter = 0; iter < this.iterations; iter = iter + 1) {
            for (i = 0; i < manifolds.length(); i = i + 1) {
                resolve_collision(manifolds.get(i));
            }
            var j = 0;
            for (j = 0; j < this.joints.length(); j = j + 1) {
                this.joints.get(j).solve(dt);
            }
        }
        
        for (i = 0; i < this.bodies.length(); i = i + 1) {
            this.bodies.get(i).integrate_velocity(dt);
        }
    }
    
    func find_collisions() {
        var manifolds = new List();
        manifolds.init();
        var i = 0;
        for (i = 0; i < this.bodies.length(); i = i + 1) {
            var j = i + 1;
            for (j = i + 1; j < this.bodies.length(); j = j + 1) {
                var a = this.bodies.get(i);
                var b = this.bodies.get(j);
                if (a.body_type == BODY_STATIC && b.body_type == BODY_STATIC) { continue; }
                var m = new Manifold();
                m.init(a, b);
                if (a.shape.type == "circle" && b.shape.type == "circle") {
                    if (circle_vs_circle(a, b, m) == 1) {
                        manifolds.append(m);
                    }
                }
            }
        }
        return manifolds;
    }
    
    func set_gravity(x, y) {
        this.gravity = vec2(x, y);
    }
}
