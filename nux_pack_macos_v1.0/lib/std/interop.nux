# Nux Interoperability Library
# Provides utilities for cross-language communication and data sharing

class CallbackBridge {
    var nux_callbacks: map
    var foreign_callbacks: map
    var next_callback_id: int
    
    fn init() {
        self.nux_callbacks = {}
        self.foreign_callbacks = {}
        self.next_callback_id = 0
    }
    
    fn register_nux_callback(callback: function) -> int {
        var callback_id = self.next_callback_id
        self.next_callback_id += 1
        self.nux_callbacks[callback_id] = callback
        return callback_id
    }
    
    fn register_foreign_callback(language: string, callback_ref: any) -> int {
        var callback_id = self.next_callback_id
        self.next_callback_id += 1
        self.foreign_callbacks[callback_id] = {
            "language": language,
            "ref": callback_ref
        }
        return callback_id
    }
    
    fn call_nux_callback(callback_id: int, args: array) -> any {
        if self.nux_callbacks.has_key(callback_id) {
            var callback = self.nux_callbacks[callback_id]
            return callback(args)
        }
        error("Callback not found: " + str(callback_id))
    }
    
    fn call_foreign_callback(callback_id: int, args: array) -> any {
        if self.foreign_callbacks.has_key(callback_id) {
            var cb_info = self.foreign_callbacks[callback_id]
            # Call the foreign callback through the language bridge
            return null
        }
        error("Foreign callback not found: " + str(callback_id))
    }
    
    fn unregister_callback(callback_id: int) {
        if self.nux_callbacks.has_key(callback_id) {
            self.nux_callbacks.remove(callback_id)
        }
        if self.foreign_callbacks.has_key(callback_id) {
            self.foreign_callbacks.remove(callback_id)
        }
    }
}

class SharedMemory {
    var buffer: array
    var size: int
    var read_only: bool
    
    fn init(size_bytes: int) {
        self.size = size_bytes
        self.buffer = []
        self.read_only = false
        
        # Initialize buffer with zeros
        for i in range(size_bytes) {
            self.buffer.push(0)
        }
    }
    
    fn write(offset: int, data: array) -> bool {
        if self.read_only {
            error("Cannot write to read-only shared memory")
            return false
        }
        
        if offset + len(data) > self.size {
            error("Write exceeds buffer size")
            return false
        }
        
        for i in range(len(data)) {
            self.buffer[offset + i] = data[i]
        }
        
        return true
    }
    
    fn read(offset: int, length: int) -> array {
        if offset + length > self.size {
            error("Read exceeds buffer size")
            return []
        }
        
        var result = []
        for i in range(length) {
            result.push(self.buffer[offset + i])
        }
        
        return result
    }
    
    fn set_read_only(read_only: bool) {
        self.read_only = read_only
    }
    
    fn get_size() -> int {
        return self.size
    }
    
    fn clear() {
        for i in range(self.size) {
            self.buffer[i] = 0
        }
    }
}

class EventBridge {
    var event_handlers: map
    var event_queue: array
    
    fn init() {
        self.event_handlers = {}
        self.event_queue = []
    }
    
    fn on(event_name: string, handler: function) {
        if !self.event_handlers.has_key(event_name) {
            self.event_handlers[event_name] = []
        }
        self.event_handlers[event_name].push(handler)
    }
    
    fn emit(event_name: string, data: any) {
        var event = {
            "name": event_name,
            "data": data,
            "timestamp": time()
        }
        
        self.event_queue.push(event)
        
        if self.event_handlers.has_key(event_name) {
            for handler in self.event_handlers[event_name] {
                handler(data)
            }
        }
    }
    
    fn emit_to_foreign(language: string, event_name: string, data: any) {
        # Emit event to foreign language runtime
        # This would use the language bridge to send the event
        var event = {
            "name": event_name,
            "data": data,
            "target_language": language
        }
        self.event_queue.push(event)
    }
    
    fn off(event_name: string, handler: function) {
        if self.event_handlers.has_key(event_name) {
            # Remove the handler from the list
            var handlers = self.event_handlers[event_name]
            var new_handlers = []
            for h in handlers {
                if h != handler {
                    new_handlers.push(h)
                }
            }
            self.event_handlers[event_name] = new_handlers
        }
    }
    
    fn clear_handlers(event_name: string) {
        if self.event_handlers.has_key(event_name) {
            self.event_handlers[event_name] = []
        }
    }
    
    fn get_event_queue() -> array {
        return self.event_queue
    }
    
    fn clear_event_queue() {
        self.event_queue = []
    }
}

class AsyncBridge {
    var pending_promises: map
    var next_promise_id: int
    
    fn init() {
        self.pending_promises = {}
        self.next_promise_id = 0
    }
    
    fn create_promise(executor: function) -> int {
        var promise_id = self.next_promise_id
        self.next_promise_id += 1
        
        var promise = {
            "id": promise_id,
            "status": "pending",
            "result": null,
            "error": null,
            "callbacks": []
        }
        
        self.pending_promises[promise_id] = promise
        
        # Execute the promise executor
        executor(
            fn(result) { self.resolve_promise(promise_id, result) },
            fn(error) { self.reject_promise(promise_id, error) }
        )
        
        return promise_id
    }
    
    fn resolve_promise(promise_id: int, result: any) {
        if self.pending_promises.has_key(promise_id) {
            var promise = self.pending_promises[promise_id]
            promise["status"] = "fulfilled"
            promise["result"] = result
            
            # Call all registered callbacks
            for callback in promise["callbacks"] {
                if callback["type"] == "then" {
                    callback["handler"](result)
                }
            }
        }
    }
    
    fn reject_promise(promise_id: int, error: any) {
        if self.pending_promises.has_key(promise_id) {
            var promise = self.pending_promises[promise_id]
            promise["status"] = "rejected"
            promise["error"] = error
            
            # Call all registered error callbacks
            for callback in promise["callbacks"] {
                if callback["type"] == "catch" {
                    callback["handler"](error)
                }
            }
        }
    }
    
    fn then(promise_id: int, on_fulfilled: function) -> int {
        if self.pending_promises.has_key(promise_id) {
            var promise = self.pending_promises[promise_id]
            
            if promise["status"] == "fulfilled" {
                # Promise already resolved, call handler immediately
                on_fulfilled(promise["result"])
            } else if promise["status"] == "pending" {
                # Register callback for later
                promise["callbacks"].push({
                    "type": "then",
                    "handler": on_fulfilled
                })
            }
        }
        return promise_id
    }
    
    fn catch(promise_id: int, on_rejected: function) -> int {
        if self.pending_promises.has_key(promise_id) {
            var promise = self.pending_promises[promise_id]
            
            if promise["status"] == "rejected" {
                # Promise already rejected, call handler immediately
                on_rejected(promise["error"])
            } else if promise["status"] == "pending" {
                # Register callback for later
                promise["callbacks"].push({
                    "type": "catch",
                    "handler": on_rejected
                })
            }
        }
        return promise_id
    }
    
    fn await_promise(promise_id: int) -> any {
        # Block until promise is resolved or rejected
        if self.pending_promises.has_key(promise_id) {
            var promise = self.pending_promises[promise_id]
            
            # In production, this would use an event loop
            while promise["status"] == "pending" {
                # Wait for promise to resolve
                sleep(10)  # Sleep 10ms
            }
            
            if promise["status"] == "fulfilled" {
                return promise["result"]
            } else {
                error("Promise rejected: " + str(promise["error"]))
            }
        }
        error("Promise not found: " + str(promise_id))
    }
    
    fn wrap_foreign_promise(language: string, foreign_promise_ref: any) -> int {
        # Wrap a foreign language promise (e.g., JavaScript Promise)
        var promise_id = self.next_promise_id
        self.next_promise_id += 1
        
        var promise = {
            "id": promise_id,
            "status": "pending",
            "result": null,
            "error": null,
            "callbacks": [],
            "foreign": {
                "language": language,
                "ref": foreign_promise_ref
            }
        }
        
        self.pending_promises[promise_id] = promise
        return promise_id
    }
}

# Global interop manager
var interop_manager = {
    "callback_bridge": CallbackBridge(),
    "event_bridge": EventBridge(),
    "async_bridge": AsyncBridge()
}

# Helper functions

fn create_shared_memory(size: int) -> SharedMemory {
    return SharedMemory(size)
}

fn register_callback(callback: function) -> int {
    return interop_manager["callback_bridge"].register_nux_callback(callback)
}

fn call_callback(callback_id: int, args: array) -> any {
    return interop_manager["callback_bridge"].call_nux_callback(callback_id, args)
}

fn on_event(event_name: string, handler: function) {
    interop_manager["event_bridge"].on(event_name, handler)
}

fn emit_event(event_name: string, data: any) {
    interop_manager["event_bridge"].emit(event_name, data)
}

fn create_promise(executor: function) -> int {
    return interop_manager["async_bridge"].create_promise(executor)
}

fn await_promise(promise_id: int) -> any {
    return interop_manager["async_bridge"].await_promise(promise_id)
}

# Export main classes and functions
export {
    CallbackBridge,
    SharedMemory,
    EventBridge,
    AsyncBridge,
    create_shared_memory,
    register_callback,
    call_callback,
    on_event,
    emit_event,
    create_promise,
    await_promise
}
