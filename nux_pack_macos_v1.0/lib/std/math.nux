// Nux Standard Library - Math Functions
// Comprehensive mathematical operations

// ===== CONSTANTS =====

const PI = 3.14159265358979323846;
const E = 2.71828182845904523536;
const TAU = 6.28318530717958647692;  // 2 * PI

// ===== BASIC ARITHMETIC =====

fn abs(x) {
    if (x < 0) {
        return -x;
    }
    return x;
}

fn ceil(x) {
    let int_part = floor(x);
    if (x > int_part) {
        return int_part + 1;
    }
    return int_part;
}

fn floor(x) {
    // Convert to int (truncates towards zero)
    let int_x = x;  // Assuming implicit conversion
    if (x < 0 && x != int_x) {
        return int_x - 1;
    }
    return int_x;
}

fn round(x) {
    if (x >= 0) {
        return floor(x + 0.5);
    } else {
        return ceil(x - 0.5);
    }
}

fn trunc(x) {
    if (x >= 0) {
        return floor(x);
    } else {
        return ceil(x);
    }
}

// ===== POWER AND ROOTS =====

fn pow(base, exponent) {
    if (exponent == 0) {
        return 1;
    }
    
    if (exponent < 0) {
        return 1 / pow(base, -exponent);
    }
    
    let result = 1;
    let i = 0;
    
    while (i < exponent) {
        result = result * base;
        i = i + 1;
    }
    
    return result;
}

fn sqrt(x) {
    if (x < 0) {
        return 0;  // NaN equivalent
    }
    
    if (x == 0) {
        return 0;
    }
    
    // Newton's method
    let guess = x / 2;
    let epsilon = 0.00001;
    let iterations = 0;
    let maxIterations = 100;
    
    while (iterations < maxIterations) {
        let newGuess = (guess + x / guess) / 2;
        
        if (abs(newGuess - guess) < epsilon) {
            return newGuess;
        }
        
        guess = newGuess;
        iterations = iterations + 1;
    }
    
    return guess;
}

fn cbrt(x) {
    let sign = 1;
    if (x < 0) {
        sign = -1;
        x = -x;
    }
    
    // Newton's method for cube root
    let guess = x / 3;
    let epsilon = 0.00001;
    let iterations = 0;
    let maxIterations = 100;
    
    while (iterations < maxIterations) {
        let newGuess = (2 * guess + x / (guess * guess)) / 3;
        
        if (abs(newGuess - guess) < epsilon) {
            return sign * newGuess;
        }
        
        guess = newGuess;
        iterations = iterations + 1;
    }
    
    return sign * guess;
}

fn exp(x) {
    // e^x using Taylor series
    let result = 1;
    let term = 1;
    let i = 1;
    
    while (i < 50) {
        term = term * x / i;
        result = result + term;
        
        if (abs(term) < 0.00001) {
            break;
        }
        
        i = i + 1;
    }
    
    return result;
}

fn log(x) {
    if (x <= 0) {
        return 0;  // NaN equivalent
    }
    
    // Natural logarithm using series expansion
    // ln(x) = 2 * ((x-1)/(x+1) + 1/3*((x-1)/(x+1))^3 + ...)
    let y = (x - 1) / (x + 1);
    let y2 = y * y;
    let result = 0;
    let term = y;
    let i = 1;
    
    while (i < 50) {
        result = result + term / i;
        term = term * y2;
        i = i + 2;
        
        if (abs(term / i) < 0.00001) {
            break;
        }
    }
    
    return 2 * result;
}

fn log10(x) {
    return log(x) / log(10);
}

fn log2(x) {
    return log(x) / log(2);
}

// ===== TRIGONOMETRY =====

fn sin(x) {
    // Normalize to [-PI, PI]
    while (x > PI) {
        x = x - TAU;
    }
    while (x < -PI) {
        x = x + TAU;
    }
    
    // Taylor series for sin(x)
    let result = 0;
    let term = x;
    let i = 1;
    
    while (i < 20) {
        result = result + term;
        term = -term * x * x / ((2 * i) * (2 * i + 1));
        i = i + 1;
        
        if (abs(term) < 0.00001) {
            break;
        }
    }
    
    return result;
}

fn cos(x) {
    // cos(x) = sin(x + PI/2)
    return sin(x + PI / 2);
}

fn tan(x) {
    let cosVal = cos(x);
    if (abs(cosVal) < 0.00001) {
        return 0;  // Infinity equivalent
    }
    return sin(x) / cosVal;
}

// ===== MIN/MAX =====

fn min(a, b) {
    if (a < b) {
        return a;
    }
    return b;
}

fn max(a, b) {
    if (a > b) {
        return a;
    }
    return b;
}

fn clamp(x, minVal, maxVal) {
    if (x < minVal) {
        return minVal;
    }
    if (x > maxVal) {
        return maxVal;
    }
    return x;
}

// ===== RANDOM =====

// Note: These are placeholder implementations
// Real implementation would use system random

let _random_seed = 12345;

fn random() {
    // Linear congruential generator
    _random_seed = (_random_seed * 1103515245 + 12345) % 2147483648;
    return _random_seed / 2147483648;
}

fn randomInt(minVal, maxVal) {
    return floor(random() * (maxVal - minVal + 1)) + minVal;
}

fn randomChoice(arr) {
    let len = arr_length(arr);
    if (len == 0) {
        return null;
    }
    let index = randomInt(0, len - 1);
    return arr[index];
}

// ===== UTILITY =====

fn sign(x) {
    if (x > 0) {
        return 1;
    }
    if (x < 0) {
        return -1;
    }
    return 0;
}

fn isEven(x) {
    return x % 2 == 0;
}

fn isOdd(x) {
    return x % 2 != 0;
}

fn gcd(a, b) {
    // Greatest common divisor
    a = abs(a);
    b = abs(b);
    
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    
    return a;
}

fn lcm(a, b) {
    // Least common multiple
    return abs(a * b) / gcd(a, b);
}

fn factorial(n) {
    if (n <= 1) {
        return 1;
    }
    
    let result = 1;
    let i = 2;
    
    while (i <= n) {
        result = result * i;
        i = i + 1;
    }
    
    return result;
}

fn isPrime(n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    
    let i = 5;
    while (i * i <= n) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
        i = i + 6;
    }
    
    return true;
}
