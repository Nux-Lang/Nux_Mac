# Nux Scientific Computing Library
# Numerical methods and scientific algorithms

import "ai.tensor";

# Numerical integration
func trapezoidal_rule(f, a, b, n) {
    var h = (b - a) / n;
    var sum = 0;
    
    var i = 1;
    for (i = 1; i < n; i = i + 1) {
        var x = a + i * h;
        sum = sum + f(x);
    }
    
    return h * (f(a) / 2 + sum + f(b) / 2);
}

func simpsons_rule(f, a, b, n) {
    var h = (b - a) / n;
    var sum = f(a) + f(b);
    
    var i = 1;
    for (i = 1; i < n; i = i + 2) {
        sum = sum + 4 * f(a + i * h);
    }
    
    for (i = 2; i < n; i = i + 2) {
        sum = sum + 2 * f(a + i * h);
    }
    
    return h * sum / 3;
}

# Root finding
func bisection(f, a, b, tolerance) {
    var fa = f(a);
    var fb = f(b);
    
    if (fa * fb > 0) {
        return 0;
    }
    
    for (;;) {
        var c = (a + b) / 2;
        var fc = f(c);
        
        if (fc < tolerance) {
            if (fc > (0 - tolerance)) {
                return c;
            }
        }
        
        if (fa * fc < 0) {
            b = c;
            fb = fc;
        }
        if (fa * fc >= 0) {
            a = c;
            fa = fc;
        }
    }
}

func newton_raphson(f, df, x0, tolerance, max_iter) {
    var x = x0;
    var iter = 0;
    
    for (iter = 0; iter < max_iter; iter = iter + 1) {
        var fx = f(x);
        var dfx = df(x);
        
        if (fx < tolerance) {
            if (fx > (0 - tolerance)) {
                return x;
            }
        }
        
        x = x - fx / dfx;
    }
    
    return x;
}

# Differential equations (Runge-Kutta 4th order)
func rk4(f, y0, t0, t_end, h) {
    var t = t0;
    var y = y0;
    
    var results = new List();
    results.init();
    
    for (;;) {
        if (t >= t_end) {
            break;
        }
        
        results.append(y);
        
        var k1 = h * f(t, y);
        var k2 = h * f(t + h / 2, y + k1 / 2);
        var k3 = h * f(t + h / 2, y + k2 / 2);
        var k4 = h * f(t + h, y + k3);
        
        y = y + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        t = t + h;
    }
    
    return results;
}

# Linear algebra
func matrix_multiply(A, B, m, n, p) {
    var C = mem_alloc_aligned(m * p * 8, 64);
    
    var i = 0;
    var j = 0;
    var k = 0;
    
    for (i = 0; i < m; i = i + 1) {
        for (j = 0; j < p; j = j + 1) {
            var sum = 0;
            for (k = 0; k < n; k = k + 1) {
                var a_val = mem_read64(A + (i * n + k) * 8);
                var b_val = mem_read64(B + (k * p + j) * 8);
                sum = sum + a_val * b_val;
            }
            mem_write64(C + (i * p + j) * 8, sum);
        }
    }
    
    return C;
}

func lu_decomposition(A, n) {
    var L = mem_alloc_aligned(n * n * 8, 64);
    var U = mem_alloc_aligned(n * n * 8, 64);
    
    var i = 0;
    var j = 0;
    var k = 0;
    
    for (i = 0; i < n; i = i + 1) {
        for (j = i; j < n; j = j + 1) {
            var sum = 0;
            for (k = 0; k < i; k = k + 1) {
                var l_val = mem_read64(L + (i * n + k) * 8);
                var u_val = mem_read64(U + (k * n + j) * 8);
                sum = sum + l_val * u_val;
            }
            var a_val = mem_read64(A + (i * n + j) * 8);
            mem_write64(U + (i * n + j) * 8, a_val - sum);
        }
        
        for (j = i; j < n; j = j + 1) {
            if (i == j) {
                mem_write64(L + (i * n + i) * 8, 1);
            }
            if (i != j) {
                var sum = 0;
                for (k = 0; k < i; k = k + 1) {
                    var l_val = mem_read64(L + (j * n + k) * 8);
                    var u_val = mem_read64(U + (k * n + i) * 8);
                    sum = sum + l_val * u_val;
                }
                var a_val = mem_read64(A + (j * n + i) * 8);
                var u_ii = mem_read64(U + (i * n + i) * 8);
                mem_write64(L + (j * n + i) * 8, (a_val - sum) / u_ii);
            }
        }
    }
    
    var result = mem_alloc_aligned(16, 8);
    mem_write64(result, L);
    mem_write64(result + 8, U);
    return result;
}

# Eigenvalue computation (Power iteration)
func power_iteration(A, n, max_iter) {
    var v = mem_alloc_aligned(n * 8, 8);
    
    var i = 0;
    for (i = 0; i < n; i = i + 1) {
        mem_write64(v + i * 8, 1);
    }
    
    var iter = 0;
    for (iter = 0; iter < max_iter; iter = iter + 1) {
        var Av = matrix_multiply(A, v, n, n, 1);
        
        var norm = 0;
        for (i = 0; i < n; i = i + 1) {
            var val = mem_read64(Av + i * 8);
            norm = norm + val * val;
        }
        norm = sqrt(norm);
        
        for (i = 0; i < n; i = i + 1) {
            var val = mem_read64(Av + i * 8);
            mem_write64(v + i * 8, val / norm);
        }
    }
    
    return v;
}

# Monte Carlo simulation
func monte_carlo_pi(n_samples) {
    var inside = 0;
    var i = 0;
    
    for (i = 0; i < n_samples; i = i + 1) {
        var x = (random() % 1000) / 1000;
        var y = (random() % 1000) / 1000;
        
        if (x * x + y * y <= 1) {
            inside = inside + 1;
        }
    }
    
    return 4 * inside / n_samples;
}
